package figure_dsl.validator;

import figure_dsl.generated.dslBaseVisitor;
import figure_dsl.generated.dslParser.Position_declarationContext;
import figure_dsl.generated.dslParser.Velocity_declarationContext;
import figure_dsl.generated.dslParser.Distance_declarationContext;
import figure_dsl.generated.dslParser.ExpressionContext;
import figure_dsl.generated.dslParser.VectorContext;

import java.util.Map;

/**
 * Validator class to check declared variables in the DSL code.
 * It extends the base visitor generated by ANTLR to override
 * specific visit methods related to variable declarations.
 */
public class DeclaredVariablesValidator extends dslBaseVisitor<Void> {
    // Reference to the main validator plugin used for error reporting and variable storage
    private final FigureValidationPlugin validator;

    /**
     * Constructor initializes with the main validator plugin.
     * @param validator main validation plugin instance
     */
    public DeclaredVariablesValidator(FigureValidationPlugin validator) {
        this.validator = validator;
    }

    /**
     * Visits a position declaration node in the parse tree.
     * Validates that the position is a vector of exactly 3 numeric components.
     * Adds the variable if valid, otherwise reports errors.
     */
    @Override
    public Void visitPosition_declaration(Position_declarationContext ctx) {
        String varName = ctx.ID().getText();
        String varType = "Position";
        VectorContext vector = ctx.vector();
        int lineNumber = ctx.getStart().getLine();

        // Check if vector has exactly 3 components (x,y,z)
        if (vector.expression().size() != 3) {
            validator.addError(String.format("[Semantic Error] Line %d: Position '%s' must be a vector with exactly 3 components.", lineNumber, varName));
            return null;
        }

        // Validate each vector component is a valid numeric expression
        for (int i = 0; i < 3; i++) {
            ExpressionContext component = vector.expression(i);
            if (!isValidNumericExpression(component)) {
                validator.addError(String.format("[Semantic Error] Line %d: Component %d of Position '%s' is not a valid numeric expression.", lineNumber, i + 1, varName));
                return null;
            }
        }

        // If all valid, build a string representation of the vector value
        String value = buildVectorValue(vector);
        // Add the variable to the declared variables map
        addVariable(varType, varName, value, lineNumber);
        return null;
    }

    /**
     * Visits a velocity declaration node.
     * Delegates validation to a generic scalar declaration validator.
     */
    @Override
    public Void visitVelocity_declaration(Velocity_declarationContext ctx) {
        return validateScalarDeclaration(ctx.ID().getText(), "Velocity", ctx.expression(), ctx.getStart().getLine());
    }

    /**
     * Visits a distance declaration node.
     * Delegates validation to a generic scalar declaration validator.
     */
    @Override
    public Void visitDistance_declaration(Distance_declarationContext ctx) {
        return validateScalarDeclaration(ctx.ID().getText(), "Distance", ctx.expression(), ctx.getStart().getLine());
    }

    /**
     * Generic validator for scalar declarations (Velocity, Distance).
     * Checks if the expression is valid numeric and adds the variable.
     * @param varName variable name
     * @param varType variable type ("Velocity" or "Distance")
     * @param expr expression context
     * @param lineNumber line number for error reporting
     * @return null always (visitor pattern requirement)
     */
    private Void validateScalarDeclaration(String varName, String varType, ExpressionContext expr, int lineNumber) {
        // Check if expression is a valid numeric expression
        if (!isValidNumericExpression(expr)) {
            validator.addError(String.format("[Semantic Error] Line %d: %s '%s' must be a valid numeric expression (number, variable or arithmetic expression).", lineNumber, varType, varName));
            return null;
        }

        // Add variable if valid
        addVariable(varType, varName, getExpressionText(expr), lineNumber);
        return null;
    }

    /**
     * Checks if the expression is a valid numeric expression.
     * Valid expressions include:
     * - A numeric literal (NUMBER)
     * - A declared variable of type Velocity or Distance
     * - Arithmetic operations between valid expressions
     * - Parenthesized valid expressions
     * @param expr expression context to validate
     * @return true if valid numeric expression, false otherwise
     */
    private boolean isValidNumericExpression(ExpressionContext expr) {
        if (expr == null) return false;

        if (expr.NUMBER() != null) {
            return true; // É um número
        } else if (expr.ID() != null) {
            String varName = expr.ID().getText();
            // Tem que ser uma variável de Velocity ou Distance
            return validator.getDeclaredVariables().get("Velocity").containsKey(varName) ||
                    validator.getDeclaredVariables().get("Distance").containsKey(varName);
        } else if (expr.expression().size() == 2) {
            // Operação binária
            return isValidNumericExpression(expr.expression(0)) &&
                    isValidNumericExpression(expr.expression(1));
        } else if (expr.expression().size() == 1) {
            // Expressão entre parêntesis
            return isValidNumericExpression(expr.expression(0));
        }

        // Anything else is invalid
        return false;
    }

    /**
     * Adds a variable to the declared variables map.
     * Reports an error if the variable is already declared.
     * @param varType variable type (Position, Velocity, Distance)
     * @param varName variable name
     * @param value string representation of the variable value
     * @param lineNumber line number for error reporting
     */
    private void addVariable(String varType, String varName, String value, int lineNumber) {
        Map<String, String> variables = validator.getDeclaredVariables().get(varType);
        if (variables.containsKey(varName)) {
            validator.addError(String.format("[Semantic Error] Line %d: Duplicate variable '%s' of type '%s' declared.", lineNumber, varName, varType));
        } else {
            variables.put(varName, value);
        }
    }

    /**
     * Builds a string representation of a vector from its components.
     * @param vector vector context containing 3 components
     * @return string formatted as "(x,y,z)"
     */
    private String buildVectorValue(VectorContext vector) {
        return String.format("(%s,%s,%s)",
                getExpressionText(vector.expression(0)),
                getExpressionText(vector.expression(1)),
                getExpressionText(vector.expression(2)));
    }

    /**
     * Retrieves the textual representation of an expression,
     * including numbers, variables, arithmetic operations, and parenthesis.
     * @param expr expression context
     * @return string representing the expression
     */
    private String getExpressionText(ExpressionContext expr) {
        if (expr == null) return "";

        if (expr.NUMBER() != null) {
            return expr.NUMBER().getText();
        } else if (expr.ID() != null) {
            return expr.ID().getText();
        } else if (expr.expression().size() == 2) {
            return String.format("%s %s %s",
                    getExpressionText(expr.expression(0)),
                    expr.getChild(1).getText(),
                    getExpressionText(expr.expression(1)));
        } else if (expr.expression().size() == 1) {
            return String.format("(%s)", getExpressionText(expr.expression(0)));
        }
        return expr.getText();
    }
}